# Presentation Layer - Рулетка Гладиаторов

## Обзор архитектуры

Этот слой отвечает за визуализацию и взаимодействие с пользователем. Он полностью отделен от доменной логики и взаимодействует с ней через события (Event Bus паттерн).

## Компоненты

### 1. ScriptableObjects (Data Layer)

**GladiatorData.cs**
- Хранит данные одного гладиатора (имя, цвет)
- Создается в редакторе Unity как ассет
- Позволяет легко добавлять/редактировать гладиаторов без изменения кода

**GladiatorDatabase.cs**
- База данных всех доступных гладиаторов
- Может выбирать случайных гладиаторов для боя
- Централизованное хранилище данных

### 2. GladiatorView.cs

**Назначение**: Визуальное представление одного гладиатора на сцене

**Ответственность**:
- Отображение прямоугольника и имени
- Анимации через DOTween:
  - Прыжок перед боем
  - Вылет при поражении
  - Подсветка при победе
- Управление видимостью (скрытие в дыму)

**Почему DOTween?**
- Плавные, производительные анимации
- Простой API для последовательностей
- Автоматическая очистка при уничтожении объектов

### 3. FightView.cs

**Назначение**: Координатор визуализации всего боя

**Ответственность**:
- Создание и размещение гладиаторов по кругу арены
- Подписка на события домена (FightStarted, FightFinished, FightReset)
- Координация анимаций всех гладиаторов
- Управление эффектом дыма

**Почему подписка на события?**
- Разделение ответственности: домен не знает о визуализации
- Легко тестировать логику отдельно от визуализации
- Можно заменить визуализацию без изменения домена

**Последовательность анимации**:
1. Прыжки всех гладиаторов (с небольшой задержкой)
2. Появление дыма (DOTween scale)
3. Скрытие гладиаторов в дыму
4. Вылет побежденных по очереди
5. Показ победителя с подсветкой

### 4. FightUIController.cs

**Назначение**: Управление UI (кнопка, текст победителя)

**Ответственность**:
- Обработка нажатия кнопки "В бой"
- Блокировка кнопки во время боя (через GameStateMachine)
- Отображение победителя
- Подписка на события для обновления UI

**Почему отдельный контроллер?**
- Разделение UI и игровой логики
- Легко изменить UI без изменения логики боя
- Соответствует принципу единственной ответственности

### 5. GameBootstrap.cs

**Назначение**: Composition Root - точка входа и инициализации

**Ответственность**:
- Создание всех зависимостей (EventBus, Fight, GameStateMachine)
- Загрузка данных из ScriptableObject
- Связывание всех компонентов
- Инициализация системы

**Почему Composition Root?**
- Централизованная инициализация
- Легко понять зависимости системы
- Соответствует паттерну Dependency Injection

## Поток данных

```
Пользователь нажимает кнопку
    ↓
FightUIController → StartFightUseCase.Execute()
    ↓
Fight.Start() → публикует FightStarted
    ↓
FightView получает событие → запускает анимацию
    ↓
Fight.ResolveWinner() → публикует FightFinished
    ↓
FightView получает победителя → завершает анимацию
FightUIController получает победителя → показывает на экране
    ↓
GameStateMachine через 2 сек → публикует FightReset
    ↓
Все компоненты сбрасываются к начальному состоянию
```

## Зависимости

- **DOTween**: Для всех анимаций
- **TextMeshPro**: Для текста (стандартный Unity UI)
- **Unity UI**: Canvas, Button, Image

## Принципы проектирования

1. **Separation of Concerns**: Домен отделен от визуализации
2. **Event-Driven**: Компоненты общаются через события
3. **Dependency Injection**: Зависимости передаются через конструкторы/методы
4. **Single Responsibility**: Каждый класс отвечает за одну вещь

## Расширяемость

Легко добавить:
- Звуковые эффекты (подписаться на события)
- Частицы (в FightView)
- Разные типы анимаций (в GladiatorView)
- Дополнительные UI элементы (в FightUIController)

